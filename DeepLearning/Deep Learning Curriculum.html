<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Deep Learning & Computer Vision Curriculum</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0f1419;
            --surface: #1a1f2e;
            --text: #e4e6eb;
            --text-dim: #b0b7c3;
            --cyan: #00d4ff;
            --orange: #ff6b35;
            --green: #00ff88;
            --yellow: #ffa500;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px 0;
            border-bottom: 2px solid var(--cyan);
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, var(--cyan), var(--orange));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .subtitle {
            color: var(--text-dim);
            font-size: 1.1em;
        }

        .dashboard {
            display: none;
        }

        .dashboard.active {
            display: block;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin: 40px 0;
        }

        .card {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(255, 107, 53, 0.1));
            border: 2px solid var(--cyan);
            border-radius: 12px;
            padding: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.2);
            border-color: var(--orange);
        }

        .card-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }

        .card h3 {
            color: var(--cyan);
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        .card p {
            color: var(--text-dim);
            font-size: 0.95em;
        }

        .category-label {
            display: inline-block;
            margin-top: 10px;
            padding: 5px 12px;
            background: rgba(0, 212, 255, 0.2);
            border-radius: 20px;
            font-size: 0.85em;
            color: var(--green);
        }

        .module {
            display: none;
        }

        .module.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .btn-back {
            padding: 10px 20px;
            background: var(--orange);
            color: var(--bg);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            margin-bottom: 25px;
            transition: all 0.3s ease;
        }

        .btn-back:hover {
            background: var(--cyan);
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
            padding-bottom: 15px;
            overflow-x: auto;
        }

        .tab-btn {
            padding: 10px 20px;
            background: var(--surface);
            color: var(--text);
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95em;
            transition: all 0.3s ease;
            font-weight: 500;
            white-space: nowrap;
        }

        .tab-btn:hover {
            background: rgba(0, 212, 255, 0.1);
            border-color: var(--cyan);
        }

        .tab-btn.active {
            background: var(--cyan);
            color: var(--bg);
            border-color: var(--cyan);
        }

        .tab {
            display: none;
        }

        .tab.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .section {
            background: var(--surface);
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 25px;
            transition: all 0.3s ease;
        }

        .section:hover {
            border-color: var(--cyan);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.1);
        }

        h2 {
            color: var(--cyan);
            font-size: 1.8em;
            margin-bottom: 15px;
        }

        h3 {
            color: var(--orange);
            font-size: 1.3em;
            margin-top: 20px;
            margin-bottom: 12px;
        }

        h4 {
            color: var(--green);
            font-size: 1.1em;
            margin-top: 15px;
            margin-bottom: 10px;
        }

        p {
            margin-bottom: 15px;
            line-height: 1.8;
        }

        ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        ul li {
            margin-bottom: 8px;
        }

        .info-box {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(255, 107, 53, 0.1));
            border: 1px solid var(--cyan);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .box-title {
            color: var(--orange);
            font-weight: 700;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .box-content {
            color: var(--text-dim);
            line-height: 1.7;
        }

        .formula {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid var(--cyan);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            line-height: 1.8;
            color: var(--cyan);
        }

        .callout {
            border-left: 4px solid;
            padding: 15px;
            margin: 20px 0;
            border-radius: 6px;
        }

        .callout.tip {
            border-left-color: var(--green);
            background: rgba(0, 255, 136, 0.05);
        }

        .callout.warning {
            border-left-color: var(--yellow);
            background: rgba(255, 165, 0, 0.05);
        }

        .callout.insight {
            border-left-color: var(--cyan);
            background: rgba(0, 212, 255, 0.05);
        }

        .callout-title {
            font-weight: 700;
            margin-bottom: 8px;
        }

        .list-item {
            display: flex;
            gap: 12px;
            margin: 12px 0;
            padding: 12px;
            background: rgba(0, 212, 255, 0.05);
            border-left: 3px solid var(--cyan);
            border-radius: 4px;
        }

        .list-num {
            color: var(--orange);
            font-weight: 700;
            min-width: 30px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th,
        td {
            padding: 12px;
            text-align: left;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }

        th {
            background: rgba(0, 212, 255, 0.1);
            color: var(--cyan);
            font-weight: 700;
        }

        .viz-container {
            background: rgba(0, 212, 255, 0.02);
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            display: flex;
            justify-content: center;
            overflow-x: auto;
        }

        .viz-controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn-viz {
            padding: 10px 20px;
            background: var(--cyan);
            color: var(--bg);
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.95em;
            transition: all 0.3s ease;
        }

        .btn-viz:hover {
            background: var(--orange);
            transform: scale(1.05);
        }

        canvas {
            max-width: 100%;
            height: auto;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .tabs {
                flex-direction: column;
            }

            .tab-btn {
                width: 100%;
            }

            .grid {
                grid-template-columns: 1fr;
            }

            canvas {
                width: 100% !important;
                height: auto !important;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- MAIN DASHBOARD -->
        <div id="dashboard" class="dashboard active">
            <header>
                <h1>üß† Complete Deep Learning & Computer Vision</h1>
                <p class="subtitle">Comprehensive Curriculum | Foundations to Advanced Applications</p>
            </header>

            <div style="text-align: center; margin-bottom: 40px;">
                <p style="color: var(--text-dim); font-size: 1.1em;">
                    Master all aspects of deep learning and computer vision. 25+ modules covering neural networks, CNNs,
                    object detection, GANs, and more.
                </p>
            </div>

            <div class="grid" id="modulesGrid"></div>
        </div>

        <!-- MODULES CONTAINER -->
        <div id="modulesContainer"></div>
    </div>

    <script>
        const modules = [
            // Module 1: Deep Learning Foundations
            {
                id: "nn-basics",
                title: "Introduction to Neural Networks",
                icon: "üß¨",
                category: "Foundations",
                color: "#0088ff",
                description: "Biological vs. Artificial neurons and network architecture"
            },
            {
                id: "perceptron",
                title: "The Perceptron",
                icon: "‚öôÔ∏è",
                category: "Foundations",
                color: "#0088ff",
                description: "Single layer networks and their limitations"
            },
            {
                id: "mlp",
                title: "Multi-Layer Perceptron (MLP)",
                icon: "üèóÔ∏è",
                category: "Foundations",
                color: "#0088ff",
                description: "Hidden layers and deep architectures"
            },
            {
                id: "activation",
                title: "Activation Functions",
                icon: "‚ö°",
                category: "Foundations",
                color: "#0088ff",
                description: "Sigmoid, ReLU, Tanh, Leaky ReLU, ELU, Softmax"
            },
            {
                id: "weight-init",
                title: "Weight Initialization",
                icon: "üéØ",
                category: "Foundations",
                color: "#0088ff",
                description: "Xavier, He, Random initialization strategies"
            },
            {
                id: "loss",
                title: "Loss Functions",
                icon: "üìâ",
                category: "Foundations",
                color: "#0088ff",
                description: "MSE, Binary Cross-Entropy, Categorical Cross-Entropy"
            },
            {
                id: "optimizers",
                title: "Optimizers",
                icon: "üéØ",
                category: "Training",
                color: "#00ff00",
                description: "SGD, Momentum, Adam, Adagrad, RMSprop"
            },
            {
                id: "backprop",
                title: "Forward & Backpropagation",
                icon: "‚¨ÖÔ∏è",
                category: "Training",
                color: "#00ff00",
                description: "Chain rule and gradient computation"
            },
            {
                id: "regularization",
                title: "Regularization",
                icon: "üõ°Ô∏è",
                category: "Training",
                color: "#00ff00",
                description: "L1/L2, Dropout, Early Stopping, Batch Norm"
            },
            {
                id: "batch-norm",
                title: "Batch Normalization",
                icon: "‚öôÔ∏è",
                category: "Training",
                color: "#00ff00",
                description: "Stabilizing and speeding up training"
            },
            // Module 2: Computer Vision Fundamentals
            {
                id: "cv-intro",
                title: "CV Fundamentals",
                icon: "üëÅÔ∏è",
                category: "Computer Vision",
                color: "#ff6b35",
                description: "Why ANNs fail with images, parameter explosion"
            },
            {
                id: "conv-layer",
                title: "Convolutional Layers",
                icon: "üñºÔ∏è",
                category: "Computer Vision",
                color: "#ff6b35",
                description: "Kernels, filters, feature maps, stride, padding"
            },
            {
                id: "pooling",
                title: "Pooling Layers",
                icon: "üì¶",
                category: "Computer Vision",
                color: "#ff6b35",
                description: "Max pooling, average pooling, spatial reduction"
            },
            {
                id: "cnn-basics",
                title: "CNN Architecture",
                icon: "üèóÔ∏è",
                category: "Computer Vision",
                color: "#ff6b35",
                description: "Combining conv, pooling, and fully connected layers"
            },
            {
                id: "viz-filters",
                title: "Visualizing CNNs",
                icon: "üîç",
                category: "Computer Vision",
                color: "#ff6b35",
                description: "What filters learn: edges ‚Üí shapes ‚Üí objects"
            },
            // Module 3: Advanced CNN Architectures
            {
                id: "lenet",
                title: "LeNet-5",
                icon: "üî¢",
                category: "CNN Architectures",
                color: "#ff00ff",
                description: "Classic digit recognizer (MNIST)"
            },
            {
                id: "alexnet",
                title: "AlexNet",
                icon: "üåü",
                category: "CNN Architectures",
                color: "#ff00ff",
                description: "The breakthrough in deep computer vision (2012)"
            },
            {
                id: "vgg",
                title: "VGGNet",
                icon: "üìä",
                category: "CNN Architectures",
                color: "#ff00ff",
                description: "VGG-16/19: Deep networks with small filters"
            },
            {
                id: "resnet",
                title: "ResNet",
                icon: "üåâ",
                category: "CNN Architectures",
                color: "#ff00ff",
                description: "Skip connections, solving vanishing gradients"
            },
            {
                id: "inception",
                title: "InceptionNet (GoogLeNet)",
                icon: "üéØ",
                category: "CNN Architectures",
                color: "#ff00ff",
                description: "1x1 convolutions, multi-scale feature extraction"
            },
            {
                id: "mobilenet",
                title: "MobileNet",
                icon: "üì±",
                category: "CNN Architectures",
                color: "#ff00ff",
                description: "Depth-wise separable convolutions for efficiency"
            },
            {
                id: "transfer-learning",
                title: "Transfer Learning",
                icon: "üîÑ",
                category: "CNN Architectures",
                color: "#ff00ff",
                description: "Fine-tuning and leveraging pre-trained models"
            },
            // Module 4: Object Detection & Segmentation
            {
                id: "localization",
                title: "Object Localization",
                icon: "üìç",
                category: "Detection",
                color: "#00ff00",
                description: "Bounding boxes and classification together"
            },
            {
                id: "rcnn",
                title: "R-CNN Family",
                icon: "üéØ",
                category: "Detection",
                color: "#00ff00",
                description: "R-CNN, Fast R-CNN, Faster R-CNN"
            },
            {
                id: "yolo",
                title: "YOLO",
                icon: "‚ö°",
                category: "Detection",
                color: "#00ff00",
                description: "Real-time object detection (v3, v5, v8)"
            },
            {
                id: "ssd",
                title: "SSD",
                icon: "üöÄ",
                category: "Detection",
                color: "#00ff00",
                description: "Single Shot MultiBox Detector"
            },
            {
                id: "semantic-seg",
                title: "Semantic Segmentation",
                icon: "üñåÔ∏è",
                category: "Segmentation",
                color: "#00ff00",
                description: "Pixel-level classification (U-Net)"
            },
            {
                id: "instance-seg",
                title: "Instance Segmentation",
                icon: "üë•",
                category: "Segmentation",
                color: "#00ff00",
                description: "Mask R-CNN and separate object instances"
            },
            {
                id: "face-recog",
                title: "Face Recognition",
                icon: "üë§",
                category: "Segmentation",
                color: "#00ff00",
                description: "Siamese networks and triplet loss"
            },
            // Module 5: Generative Models
            {
                id: "autoencoders",
                title: "Autoencoders",
                icon: "üîÄ",
                category: "Generative",
                color: "#ffaa00",
                description: "Encoder-decoder, latent space, denoising"
            },
            {
                id: "gans",
                title: "GANs (Generative Adversarial Networks)",
                icon: "üéÆ",
                category: "Generative",
                color: "#ffaa00",
                description: "Generator vs. Discriminator, DCGAN"
            },
            {
                id: "diffusion",
                title: "Diffusion Models",
                icon: "üåä",
                category: "Generative",
                color: "#ffaa00",
                description: "Foundation of Stable Diffusion and DALL-E"
            },
            // Additional Advanced Topics
            {
                id: "rnn",
                title: "RNNs & LSTMs",
                icon: "üîÑ",
                category: "Sequence",
                color: "#ff6b35",
                description: "Recurrent networks for sequential data"
            },
            {
                id: "transformers",
                title: "Transformers",
                icon: "üîó",
                category: "Sequence",
                color: "#ff6b35",
                description: "Attention mechanisms and modern architectures"
            },
            {
                id: "bert",
                title: "BERT & NLP Transformers",
                icon: "üìö",
                category: "NLP",
                color: "#ff6b35",
                description: "Bidirectional transformers for language"
            },
            {
                id: "gpt",
                title: "GPT & Language Models",
                icon: "üí¨",
                category: "NLP",
                color: "#ff6b35",
                description: "Autoregressive models and text generation"
            },
            {
                id: "vit",
                title: "Vision Transformers (ViT)",
                icon: "üé®",
                category: "Vision",
                color: "#ff6b35",
                description: "Transformers applied to image data"
            }
        ];

        // Comprehensive content for all modules
        const MODULE_CONTENT = {
            "nn-basics": {
                overview: `
                    <h3>What are Neural Networks?</h3>
                    <p>Neural Networks are computational models inspired by the human brain's structure. They consist of interconnected nodes (neurons) organized in layers that process information through weighted connections.</p>
                    
                    <h3>Why Use Neural Networks?</h3>
                    <ul>
                        <li><strong>Universal Approximation:</strong> Can theoretically approximate any continuous function</li>
                        <li><strong>Feature Learning:</strong> Automatically discover representations from raw data</li>
                        <li><strong>Adaptability:</strong> Learn from examples without explicit programming</li>
                        <li><strong>Parallel Processing:</strong> Highly parallelizable for modern hardware</li>
                    </ul>
                    
                    <div class="callout tip">
                        <div class="callout-title">‚úÖ Advantages</div>
                        ‚Ä¢ Non-linear problem solving<br>
                        ‚Ä¢ Robust to noisy data<br>
                        ‚Ä¢ Works with incomplete information<br>
                        ‚Ä¢ Continuous learning capability
                    </div>
                    
                    <div class="callout warning">
                        <div class="callout-title">‚ö†Ô∏è Disadvantages</div>
                        ‚Ä¢ Requires large amounts of training data<br>
                        ‚Ä¢ Computationally expensive<br>
                        ‚Ä¢ "Black box" - difficult to interpret<br>
                        ‚Ä¢ Prone to overfitting without regularization
                    </div>
                `,
                concepts: `
                    <h3>Core Components</h3>
                    <div class="list-item">
                        <div class="list-num">01</div>
                        <div><strong>Neurons (Nodes):</strong> Basic computational units that receive inputs, apply weights, add bias, and apply activation function</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">02</div>
                        <div><strong>Layers:</strong> Input layer (receives data), Hidden layers (feature extraction), Output layer (predictions)</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">03</div>
                        <div><strong>Weights:</strong> Parameters learned during training that determine connection strength</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">04</div>
                        <div><strong>Bias:</strong> Allows shifting the activation function for better fitting</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">05</div>
                        <div><strong>Activation Function:</strong> Introduces non-linearity (ReLU, Sigmoid, Tanh)</div>
                    </div>
                `,
                applications: `
                    <h3>Real-World Applications</h3>
                    <div class="info-box">
                        <div class="box-title">üè• Healthcare</div>
                        <div class="box-content">Disease diagnosis, medical image analysis, drug discovery, patient risk prediction</div>
                    </div>
                    <div class="info-box">
                        <div class="box-title">üí∞ Finance</div>
                        <div class="box-content">Fraud detection, algorithmic trading, credit scoring, portfolio optimization</div>
                    </div>
                    <div class="info-box">
                        <div class="box-title">üõí E-commerce</div>
                        <div class="box-content">Recommendation systems, demand forecasting, customer segmentation, price optimization</div>
                    </div>
                `
            },
            "activation": {
                overview: `
                    <h3>What are Activation Functions?</h3>
                    <p>Activation functions introduce non-linearity into neural networks, enabling them to learn complex patterns. Without activation functions, a neural network would be just a linear regression model regardless of depth.</p>
                    
                    <h3>Why Do We Need Them?</h3>
                    <ul>
                        <li><strong>Non-linearity:</strong> Real-world problems are rarely linear</li>
                        <li><strong>Complex Pattern Learning:</strong> Enable learning of intricate decision boundaries</li>
                        <li><strong>Gradient Flow:</strong> Control how gradients propagate during backpropagation</li>
                        <li><strong>Range Normalization:</strong> Keep activations in manageable ranges</li>
                    </ul>
                    
                    <h3>Common Activation Functions Comparison</h3>
                    <table>
                        <tr>
                            <th>Function</th>
                            <th>Range</th>
                            <th>Best Use</th>
                            <th>Issue</th>
                        </tr>
                        <tr>
                            <td>ReLU</td>
                            <td>[0, ‚àû)</td>
                            <td>Hidden layers (default)</td>
                            <td>Dying ReLU problem</td>
                        </tr>
                        <tr>
                            <td>Sigmoid</td>
                            <td>(0, 1)</td>
                            <td>Binary classification output</td>
                            <td>Vanishing gradients</td>
                        </tr>
                        <tr>
                            <td>Tanh</td>
                            <td>(-1, 1)</td>
                            <td>RNNs, zero-centered</td>
                            <td>Vanishing gradients</td>
                        </tr>
                        <tr>
                            <td>Leaky ReLU</td>
                            <td>(-‚àû, ‚àû)</td>
                            <td>Fixes dying ReLU</td>
                            <td>Extra hyperparameter</td>
                        </tr>
                        <tr>
                            <td>Softmax</td>
                            <td>(0, 1) sum=1</td>
                            <td>Multi-class output</td>
                            <td>Computationally expensive</td>
                        </tr>
                    </table>
                `,
                concepts: `
                    <h3>Key Properties</h3>
                    <div class="list-item">
                        <div class="list-num">01</div>
                        <div><strong>Differentiability:</strong> Must have derivatives for backpropagation to work</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">02</div>
                        <div><strong>Monotonicity:</strong> Preferably monotonic for easier optimization</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">03</div>
                        <div><strong>Zero-Centered:</strong> Helps with faster convergence (Tanh)</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">04</div>
                        <div><strong>Computational Efficiency:</strong> Should be fast to compute (ReLU wins)</div>
                    </div>
                    
                    <div class="callout tip">
                        <div class="callout-title">üí° Best Practices</div>
                        ‚Ä¢ Use <strong>ReLU</strong> for hidden layers by default<br>
                        ‚Ä¢ Use <strong>Sigmoid</strong> for binary classification output<br>
                        ‚Ä¢ Use <strong>Softmax</strong> for multi-class classification<br>
                        ‚Ä¢ Try <strong>Leaky ReLU</strong> or <strong>ELU</strong> if ReLU neurons are dying<br>
                        ‚Ä¢ Avoid Sigmoid/Tanh in deep networks (gradient vanishing)
                    </div>
                `
            },
            "conv-layer": {
                overview: `
                    <h3>What are Convolutional Layers?</h3>
                    <p>Convolutional layers are the fundamental building blocks of CNNs. They apply learnable filters (kernels) across input data to detect local patterns like edges, textures, and shapes.</p>
                    
                    <h3>Why Use Convolutions Instead of Fully Connected Layers?</h3>
                    <ul>
                        <li><strong>Parameter Efficiency:</strong> Share weights across spatial locations (fewer parameters)</li>
                        <li><strong>Translation Invariance:</strong> Detect features regardless of position</li>
                        <li><strong>Local Connectivity:</strong> Each neuron sees

 only a small region (receptive field)</li>
                        <li><strong>Hierarchical Learning:</strong> Build complex features from simple ones</li>
                    </ul>
                    
                    <div class="callout insight">
                        <div class="callout-title">üîç Example: Parameter Comparison</div>
                        For a 224√ó224 RGB image:<br>
                        ‚Ä¢ <strong>Fully Connected:</strong> 224 √ó 224 √ó 3 √ó 1000 = 150M parameters (for 1000 neurons)<br>
                        ‚Ä¢ <strong>Convolutional (3√ó3):</strong> 3 √ó 3 √ó 3 √ó 64 = 1,728 parameters (for 64 filters)<br>
                        <strong>Result:</strong> 87,000x fewer parameters! üöÄ
                    </div>
                    
                    <div class="callout tip">
                        <div class="callout-title">‚úÖ Advantages</div>
                        ‚Ä¢ Drastically reduced parameters<br>
                        ‚Ä¢ Spatial hierarchy (edges ‚Üí textures ‚Üí parts ‚Üí objects)<br>
                        ‚Ä¢ GPU-friendly (highly parallelizable)<br>
                        ‚Ä¢ Built-in translation equivariance
                    </div>
                    
                    <div class="callout warning">
                        <div class="callout-title">‚ö†Ô∏è Disadvantages</div>
                        ‚Ä¢ Not rotation invariant (require data augmentation)<br>
                        ‚Ä¢ Fixed receptive field size<br>
                        ‚Ä¢ Memory intensive during training<br>
                        ‚Ä¢ Require careful hyperparameter tuning (kernel size, stride, padding)
                    </div>
                `,
                concepts: `
                    <h3>Key Hyperparameters</h3>
                    <div class="list-item">
                        <div class="list-num">01</div>
                        <div><strong>Kernel/Filter Size:</strong> Typically 3√ó3 or 5√ó5. Smaller = more layers needed, larger = more parameters</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">02</div>
                        <div><strong>Stride:</strong> Step size when sliding filter. Stride=1 (preserves size), Stride=2 (downsamples by 2√ó)</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">03</div>
                        <div><strong>Padding:</strong> Add zeros around borders. 'SAME' keeps size, 'VALID' shrinks output</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">04</div>
                        <div><strong>Number of Filters:</strong> Each filter learns different features. More filters = more capacity but slower</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">05</div>
                        <div><strong>Dilation:</strong> Spacing between kernel elements. Increases receptive field without adding parameters</div>
                    </div>

                    <div class="formula">
                        Output Size Formula:<br>
                        W_out = floor((W_in + 2√ópadding - kernel_size) / stride) + 1<br>
                        H_out = floor((H_in + 2√ópadding - kernel_size) / stride) + 1
                    </div>
                `
            },
            "yolo": {
                overview: `
                    <h3>What is YOLO?</h3>
                    <p>YOLO (You Only Look Once) treats object detection as a single regression problem, going directly from image pixels to bounding box coordinates and class probabilities in one forward pass.</p>
                    
                    <h3>Why YOLO Over R-CNN?</h3>
                    <ul>
                        <li><strong>Speed:</strong> 45+ FPS (real-time) vs R-CNN's ~0.05 FPS</li>
                        <li><strong>Global Context:</strong> Sees entire image during training (fewer background errors)</li>
                        <li><strong>One Network:</strong> Unlike R-CNN's multi-stage pipeline</li>
                        <li><strong>End-to-End Training:</strong> Optimize detection directly</li>
                    </ul>
                    
                    <div class="callout tip">
                        <div class="callout-title">‚úÖ Advantages</div>
                        ‚Ä¢ <strong>Lightning Fast:</strong> Real-time inference (YOLOv8 at 100+ FPS)<br>
                        ‚Ä¢ <strong>Simple Architecture:</strong> Single network, easy to train<br>
                        ‚Ä¢ <strong>Generalizes Well:</strong> Works on natural images and artwork<br>
                        ‚Ä¢ <strong>Small Model Size:</strong> Can run on edge devices (mobile, IoT)
                    </div>
                    
                    <div class="callout warning">
                        <div class="callout-title">‚ö†Ô∏è Disadvantages</div>
                        ‚Ä¢ <strong>Struggles with Small Objects:</strong> Grid limitation affects tiny items<br>
                        ‚Ä¢ <strong>Localization Errors:</strong> Less precise than two-stage detectors<br>
                        ‚Ä¢ <strong>Limited Objects per Cell:</strong> Can't detect many close objects<br>
                        ‚Ä¢ <strong>Aspect Ratio Issues:</strong> Struggles with unusual object shapes
                    </div>
                    
                    <h3>YOLO Evolution</h3>
                    <table>
                        <tr>
                            <th>Version</th>
                            <th>Year</th>
                            <th>Key Innovation</th>
                            <th>mAP</th>
                        </tr>
                        <tr>
                            <td>YOLOv1</td>
                            <td>2015</td>
                            <td>Original single-shot detector</td>
                            <td>63.4%</td>
                        </tr>
                        <tr>
                            <td>YOLOv3</td>
                            <td>2018</td>
                            <td>Multi-scale predictions</td>
                            <td>57.9% (faster)</td>
                        </tr>
                        <tr>
                            <td>YOLOv5</td>
                            <td>2020</td>
                            <td>PyTorch, Auto-augment</td>
                            <td>~50% (optimized)</td>
                        </tr>
                        <tr>
                            <td>YOLOv8</td>
                            <td>2023</td>
                            <td>Anchor-free, SOTA speed</td>
                            <td>53.9% (real-time)</td>
                        </tr>
                    </table>
                `,
                concepts: `
                    <h3>How YOLO Works (3 Steps)</h3>
                    <div class="list-item">
                        <div class="list-num">01</div>
                        <div><strong>Grid Division:</strong> Divide image into S√óS grid (e.g., 7√ó7). Each cell predicts B bounding boxes</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">02</div>
                        <div><strong>Predictions Per Cell:</strong> Each box predicts (x, y, w, h, confidence) + class probabilities</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">03</div>
                        <div><strong>Non-Max Suppression:</strong> Remove duplicate detections, keep highest confidence boxes</div>
                    </div>
                    
                    <div class="formula">
                        Output Tensor Shape (YOLOv1):<br>
                        S √ó S √ó (B √ó 5 + C)<br>
                        Example: 7 √ó 7 √ó (2 √ó 5 + 20) = 7 √ó 7 √ó 30<br>
                        <br>
                        Where:<br>
                        ‚Ä¢ S = grid size (7)<br>
                        ‚Ä¢ B = boxes per cell (2)<br>
                        ‚Ä¢ 5 = (x, y, w, h, confidence)<br>
                        ‚Ä¢ C = number of classes (20 for PASCAL VOC)
                    </div>
                `,
                applications: `
                    <h3>Industry Applications</h3>
                    <div class="info-box">
                        <div class="box-title">üöó Autonomous Vehicles</div>
                        <div class="box-content">
                            Real-time detection of pedestrians, vehicles, traffic signs, and lane markings for self-driving cars
                        </div>
                    </div>
                    <div class="info-box">
                        <div class="box-title">üè≠ Manufacturing</div>
                        <div class="box-content">
                            Quality control, defect detection on assembly lines, robot guidance, inventory management
                        </div>
                    </div>
                    <div class="info-box">
                        <div class="box-title">üõ°Ô∏è Security & Surveillance</div>
                        <div class="box-content">
                            Intrusion detection, crowd monitoring, suspicious behavior analysis, license plate recognition
                        </div>
                    </div>
                    <div class="info-box">
                        <div class="box-title">üè• Medical Imaging</div>
                        <div class="box-content">
                            Tumor localization, cell counting, anatomical structure detection in X-rays/CT scans
                        </div>
                    </div>
                `
            },
            "transformers": {
                overview: `
                    <h3>What are Transformers?</h3>
                    <p>Transformers are neural architectures based entirely on attention mechanisms, eliminating recurrence and convolutions. Introduced in "Attention is All You Need" (2017), they revolutionized NLP and are now conquering computer vision.</p>
                    
                    <h3>Why Transformers Over RNNs/LSTMs?</h3>
                    <ul>
                        <li><strong>Parallelization:</strong> Process entire sequence at once (vs sequential RNNs)</li>
                        <li><strong>Long-Range Dependencies:</strong> Direct connections between any two positions</li>
                        <li><strong>No Gradient Vanishing:</strong> Skip connections and attention bypass depth issues</li>
                        <li><strong>Scalability:</strong> Performance improves with more data and compute</li>
                    </ul>
                    
                    <div class="callout tip">
                        <div class="callout-title">‚úÖ Advantages</div>
                        ‚Ä¢ <strong>Superior Performance:</strong> SOTA on nearly all NLP benchmarks<br>
                        ‚Ä¢ <strong>Highly Parallelizable:</strong> Train 100√ó faster than RNNs on TPUs/GPUs<br>
                        ‚Ä¢ <strong>Transfer Learning:</strong> Pre-train once, fine-tune for many tasks<br>
                        ‚Ä¢ <strong>Interpretability:</strong> Attention weights show what model focuses on<br>
                        ‚Ä¢ <strong>Multi-Modal:</strong> Works for text, images, audio, video
                    </div>
                    
                    <div class="callout warning">
                        <div class="callout-title">‚ö†Ô∏è Disadvantages</div>
                        ‚Ä¢ <strong>Quadratic Complexity:</strong> O(n¬≤) in sequence length (memory intensive)<br>
                        ‚Ä¢ <strong>Massive Data Requirements:</strong> Need millions of examples to train from scratch<br>
                        ‚Ä¢ <strong>Computational Cost:</strong> Training GPT-3 cost ~$4.6M<br>
                        ‚Ä¢ <strong>Position Encoding:</strong> Require explicit positional information<br>
                        ‚Ä¢ <strong>Limited Context:</strong> Most models cap at 512-4096 tokens
                    </div>
                    
                    <h3>Transformer Variants</h3>
                    <table>
                        <tr>
                            <th>Model</th>
                            <th>Type</th>
                            <th>Architecture</th>
                            <th>Best For</th>
                        </tr>
                        <tr>
                            <td>BERT</td>
                            <td>Encoder-only</td>
                            <td>Bidirectional</td>
                            <td>Understanding (classification, QA)</td>
                        </tr>
                        <tr>
                            <td>GPT</td>
                            <td>Decoder-only</td>
                            <td>Autoregressive</td>
                            <td>Generation (text, code)</td>
                        </tr>
                        <tr>
                            <td>T5</td>
                            <td>Encoder-Decoder</td>
                            <td>Full Transformer</td>
                            <td>Text-to-text tasks (translation)</td>
                        </tr>
                        <tr>
                            <td>ViT</td>
                            <td>Encoder-only</td>
                            <td>Patch embeddings</td>
                            <td>Image classification</td>
                        </tr>
                    </table>
                `,
                concepts: `
                    <h3>Core Components</h3>
                    <div class="list-item">
                        <div class="list-num">01</div>
                        <div><strong>Self-Attention:</strong> Each token attends to all other tokens, learning contextual relationships</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">02</div>
                        <div><strong>Multi-Head Attention:</strong> Multiple attention mechanisms in parallel (8-16 heads), each learning different patterns</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">03</div>
                        <div><strong>Positional Encoding:</strong> Add position information since attention is permutation-invariant</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">04</div>
                        <div><strong>Feed-Forward Networks:</strong> Two-layer MLPs applied to each position independently</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">05</div>
                        <div><strong>Layer Normalization:</strong> Stabilize training, applied before attention and FFN</div>
                    </div>
                    <div class="list-item">
                        <div class="list-num">06</div>
                        <div><strong>Residual Connections:</strong> Skip connections around each sub-layer for gradient flow</div>
                    </div>
                    
                    <div class="formula">
                        Self-Attention Formula:<br>
                        Attention(Q, K, V) = softmax(QK<sup>T</sup> / ‚àöd<sub>k</sub>) V<br>
                        <br>
                        Where:<br>
                        ‚Ä¢ Q = Queries (what we're looking for)<br>
                        ‚Ä¢ K = Keys (what each token represents)<br>
                        ‚Ä¢ V = Values (actual information to aggregate)<br>
                        ‚Ä¢ d<sub>k</sub> = dimension of keys (for scaling)<br>
                        <br>
                        Multi-Head Attention:<br>
                        MultiHead(Q,K,V) = Concat(head‚ÇÅ,...,head<sub>h</sub>)W<sup>O</sup><br>
                        where head<sub>i</sub> = Attention(QW<sub>i</sub><sup>Q</sup>, KW<sub>i</sub><sup>K</sup>, VW<sub>i</sub><sup>V</sup>)
                    </div>
                `,
                applications: `
                    <h3>Revolutionary Applications</h3>
                    <div class="info-box">
                        <div class="box-title">üí¨ Large Language Models</div>
                        <div class="box-content">
                            <strong>ChatGPT, GPT-4, Claude:</strong> Conversational AI, code generation, creative writing, reasoning<br>
                            <strong>BERT, RoBERTa:</strong> Search engines (Google), question answering, sentiment analysis
                        </div>
                    </div>
                    <div class="info-box">
                        <div class="box-title">üåê Machine Translation</div>
                        <div class="box-content">
                            <strong>Google Translate, DeepL:</strong> Transformers achieved human-level translation quality<br>
                            Supports 100+ languages, real-time translation
                        </div>
                    </div>
                    <div class="info-box">
                        <div class="box-title">üé® Multi-Modal AI</div>
                        <div class="box-content">
                            <strong>DALL-E, Midjourney:</strong> Text-to-image generation<br>
                            <strong>CLIP:</strong> Image-text understanding<br>
                            <strong>Whisper:</strong> Speech recognition
                        </div>
                    </div>
                    <div class="info-box">
                        <div class="box-title">üß¨ Scientific Discovery</div>
                        <div class="box-content">
                            <strong>AlphaFold:</strong> Protein structure prediction (Nobel Prize-worthy breakthrough)<br>
                            <strong>Drug Discovery:</strong> Molecule generation and property prediction
                        </div>
                    </div>
                    <div class="info-box">
                        <div class="box-title">üíª Code Intelligence</div>
                        <div class="box-content">
                            <strong>GitHub Copilot:</strong> AI pair programmer<br>
                            <strong>CodeGen, AlphaCode:</strong> Automated coding, bug detection
                        </div>
                    </div>
                `
            }
        };

        function createModuleHTML(module) {
            const content = MODULE_CONTENT[module.id] || {};

            return `
                <div class="module" id="${module.id}-module">
                    <button class="btn-back" onclick="switchTo('dashboard')">‚Üê Back to Dashboard</button>
                    <header>
                        <h1>${module.icon} ${module.title}</h1>
                        <p class="subtitle">${module.description}</p>
                    </header>

                    <div class="tabs">
                        <button class="tab-btn active" onclick="switchTab(event, '${module.id}-overview')">Overview</button>
                        <button class="tab-btn" onclick="switchTab(event, '${module.id}-concepts')">Key Concepts</button>
                        <button class="tab-btn" onclick="switchTab(event, '${module.id}-visualization')">üìä Visualization</button>
                        <button class="tab-btn" onclick="switchTab(event, '${module.id}-math')">Math</button>
                        <button class="tab-btn" onclick="switchTab(event, '${module.id}-applications')">Applications</button>
                        <button class="tab-btn" onclick="switchTab(event, '${module.id}-summary')">Summary</button>
                    </div>

                    <div id="${module.id}-overview" class="tab active">
                        <div class="section">
                            <h2>üìñ Overview</h2>
                            ${content.overview || `
                                <p>Complete coverage of ${module.title.toLowerCase()}. Learn the fundamentals, mathematics, real-world applications, and implementation details.</p>
                                <div class="info-box">
                                    <div class="box-title">Learning Objectives</div>
                                    <div class="box-content">
                                        ‚úì Understand core concepts and theory<br>
                                        ‚úì Master mathematical foundations<br>
                                        ‚úì Learn practical applications<br>
                                        ‚úì Implement and experiment
                                    </div>
                                </div>
                            `}
                        </div>
                    </div>

                    <div id="${module.id}-concepts" class="tab">
                        <div class="section">
                            <h2>üéØ Key Concepts</h2>
                            ${content.concepts || `
                                <p>Fundamental concepts and building blocks for ${module.title.toLowerCase()}.</p>
                                <div class="callout insight">
                                    <div class="callout-title">üí° Main Ideas</div>
                                    This section covers the core ideas you need to understand before diving into mathematics.
                                </div>
                            `}
                        </div>
                    </div>

                    <div id="${module.id}-visualization" class="tab">
                        <div class="section">
                            <h2>üìä Interactive Visualization</h2>
                            <p>Visual representation to help understand ${module.title.toLowerCase()} concepts intuitively.</p>
                            <div id="${module.id}-viz" class="viz-container">
                                <canvas id="${module.id}-canvas" width="800" height="400" style="border: 1px solid rgba(0, 212, 255, 0.3); border-radius: 8px; background: rgba(0, 212, 255, 0.02);"></canvas>
                            </div>
                            <div class="viz-controls">
                                <button onclick="drawVisualization('${module.id}')" class="btn-viz">üîÑ Refresh Visualization</button>
                                <button onclick="toggleVizAnimation('${module.id}')" class="btn-viz">‚ñ∂Ô∏è Animate</button>
                                <button onclick="downloadViz('${module.id}')" class="btn-viz">‚¨áÔ∏è Save Image</button>
                            </div>
                        </div>
                    </div>

                    <div id="${module.id}-math" class="tab">
                        <div class="section">
                            <h2>üìê Mathematical Foundation</h2>
                            <p>Rigorous mathematical treatment of ${module.title.toLowerCase()}.</p>
                            <div class="formula">
                                Mathematical formulas and derivations go here
                            </div>
                        </div>
                        <div class="section">
                            <h2>üìä Mathematical Visualization</h2>
                            <div id="${module.id}-math-viz" class="viz-container">
                                <canvas id="${module.id}-math-canvas" width="800" height="400" style="border: 1px solid rgba(0, 212, 255, 0.3); border-radius: 8px; background: rgba(0, 212, 255, 0.02);"></canvas>
                            </div>
                            <div class="viz-controls">
                                <button onclick="drawMathVisualization('${module.id}')" class="btn-viz">üîÑ Visualize Equations</button>
                            </div>
                        </div>
                    </div>

                    <div id="${module.id}-applications" class="tab">
                        <div class="section">
                            <h2>üåç Real-World Applications</h2>
                            ${content.applications || `
                                <p>How ${module.title.toLowerCase()} is used in practice across different industries.</p>
                                <div class="info-box">
                                    <div class="box-title">Use Cases</div>
                                    <div class="box-content">
                                        Common applications and practical examples
                                    </div>
                                </div>
                            `}
                        </div>
                        <div class="section">
                            <h2>üìä Application Scenarios Visualization</h2>
                            <div id="${module.id}-app-viz" class="viz-container">
                                <canvas id="${module.id}-app-canvas" width="800" height="400" style="border: 1px solid rgba(0, 212, 255, 0.3); border-radius: 8px; background: rgba(0, 212, 255, 0.02);"></canvas>
                            </div>
                            <div class="viz-controls">
                                <button onclick="drawApplicationVisualization('${module.id}')" class="btn-viz">üîÑ Show Applications</button>
                            </div>
                        </div>
                    </div>

                    <div id="${module.id}-summary" class="tab">
                        <div class="section">
                            <h2>‚úÖ Summary</h2>
                            <div class="info-box">
                                <div class="box-title">Key Takeaways</div>
                                <div class="box-content">
                                    ‚úì Essential concepts covered<br>
                                    ‚úì Mathematical foundations understood<br>
                                    ‚úì Real-world applications identified<br>
                                    ‚úì Ready for implementation
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function initDashboard() {
            const grid = document.getElementById("modulesGrid");
            const container = document.getElementById("modulesContainer");

            modules.forEach(module => {
                const card = document.createElement("div");
                card.className = "card";
                card.style.borderColor = module.color;
                card.onclick = () => switchTo(module.id + "-module");
                card.innerHTML = `
                    <div class="card-icon">${module.icon}</div>
                    <h3>${module.title}</h3>
                    <p>${module.description}</p>
                    <span class="category-label">${module.category}</span>
                `;
                grid.appendChild(card);

                const moduleHTML = createModuleHTML(module);
                container.innerHTML += moduleHTML;
            });
        }

        function switchTo(target) {
            document.querySelectorAll('.dashboard, .module').forEach(el => {
                el.classList.remove('active');
            });
            const elem = document.getElementById(target);
            if (elem) elem.classList.add('active');
        }

        function switchTab(e, tabId) {
            const module = e.target.closest('.module');
            if (!module) return;

            module.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            module.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));

            const tab = document.getElementById(tabId);
            if (tab) tab.classList.add('active');
            e.target.classList.add('active');

            // Trigger visualization when tabs are clicked
            setTimeout(() => {
                const moduleId = tabId.split('-')[0];
                if (tabId.includes('-concepts')) {
                    drawConceptsVisualization(moduleId);
                } else if (tabId.includes('-visualization')) {
                    drawConceptsVisualization(moduleId);
                } else if (tabId.includes('-math')) {
                    drawMathVisualization(moduleId);
                } else if (tabId.includes('-applications')) {
                    drawApplicationVisualization(moduleId);
                }
            }, 150);
        }

        // Visualization Functions - Concepts Tab
        function drawConceptsVisualization(moduleId) {
            const canvas = document.getElementById(moduleId + '-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0f1419';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const vizMap = {
                'nn-basics': drawNeuronAnimation,
                'perceptron': drawDecisionBoundary,
                'mlp': drawNetworkGraph,
                'activation': drawActivationFunctions,
                'weight-init': drawWeightDistribution,
                'loss': drawLossLandscape,
                'optimizers': drawConvergencePaths,
                'backprop': drawGradientFlow,
                'regularization': drawOverfitComparison,
                'batch-norm': drawBatchNormalization,
                'cv-intro': drawImageMatrix,
                'conv-layer': drawConvolutionAnimation,
                'pooling': drawPoolingDemo,
                'cnn-basics': drawCNNArchitecture,
                'viz-filters': drawLearnedFilters,
                'lenet': drawLeNetArchitecture,
                'alexnet': drawAlexNetArchitecture,
                'vgg': drawVGGArchitecture,
                'resnet': drawResNetArchitecture,
                'inception': drawInceptionModule,
                'mobilenet': drawMobileNetArchitecture,
                'transfer-learning': drawTransferLearning,
                'localization': drawBoundingBoxes,
                'rcnn': drawRCNNPipeline,
                'yolo': drawYOLOGrid,
                'ssd': drawSSDDetector,
                'semantic-seg': drawSemanticSegmentation,
                'instance-seg': drawInstanceSegmentation,
                'face-recog': drawFaceEmbeddings,
                'autoencoders': drawAutoencoderArchitecture,
                'gans': drawGANsGame,
                'diffusion': drawDiffusionProcess,
                'rnn': drawRNNUnrolled,
                'transformers': drawAttentionMatrix,
                'bert': drawBERTProcess,
                'gpt': drawGPTGeneration,
                'vit': drawVisionTransformer
            };

            if (vizMap[moduleId]) {
                vizMap[moduleId](ctx, canvas);
            } else {
                drawDefaultVisualization(ctx, canvas);
            }
        }

        // Default Visualization
        function drawDefaultVisualization(ctx, canvas) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.fillStyle = 'rgba(0, 212, 255, 0.2)';
            ctx.fillRect(centerX - 120, centerY - 60, 240, 120);
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.strokeRect(centerX - 120, centerY - 60, 240, 120);

            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üìä Interactive Visualization', centerX, centerY - 20);
            ctx.font = '13px Arial';
            ctx.fillText('Custom visualization for this topic', centerX, centerY + 20);
            ctx.font = '11px Arial';
            ctx.fillStyle = '#00ff88';
            ctx.fillText('Click Refresh to render', centerX, centerY + 45);
        }

        // Default Math Visualization
        function drawDefaultMathVisualization(ctx, canvas) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.fillStyle = 'rgba(255, 107, 53, 0.2)';
            ctx.fillRect(centerX - 120, centerY - 60, 240, 120);
            ctx.strokeStyle = '#ff6b35';
            ctx.lineWidth = 2;
            ctx.strokeRect(centerX - 120, centerY - 60, 240, 120);

            ctx.fillStyle = '#ff6b35';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üìê Mathematical Formulas', centerX, centerY - 20);
            ctx.font = '13px Arial';
            ctx.fillText('Visual equation derivations', centerX, centerY + 20);
            ctx.font = '11px Arial';
            ctx.fillStyle = '#00ff88';
            ctx.fillText('Click Visualize to render', centerX, centerY + 45);
        }

        // Default Application Visualization
        function drawDefaultApplicationVisualization(ctx, canvas) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.fillStyle = 'rgba(0, 255, 136, 0.2)';
            ctx.fillRect(centerX - 120, centerY - 60, 240, 120);
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.strokeRect(centerX - 120, centerY - 60, 240, 120);

            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üåç Real-World Applications', centerX, centerY - 20);
            ctx.font = '13px Arial';
            ctx.fillText('Practical use cases and examples', centerX, centerY + 20);
            ctx.font = '11px Arial';
            ctx.fillStyle = '#ffa500';
            ctx.fillText('Click Show Applications to render', centerX, centerY + 45);
        }

        // Activation Functions Visualization
        function drawActivationFunctions(ctx, canvas) {
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const scale = 40;

            // Draw grid
            ctx.strokeStyle = 'rgba(0, 212, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = -5; i <= 5; i += 1) {
                const x = centerX + i * scale;
                ctx.beginPath();
                ctx.moveTo(x, centerY - 5 * scale);
                ctx.lineTo(x, centerY + 5 * scale);
                ctx.stroke();
            }

            // Draw axes
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX - 6 * scale, centerY);
            ctx.lineTo(centerX + 6 * scale, centerY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - 6 * scale);
            ctx.lineTo(centerX, centerY + 6 * scale);
            ctx.stroke();

            // Draw activation functions
            const functions = [
                { name: 'ReLU', color: '#ff6b35', fn: x => Math.max(0, x) },
                { name: 'Sigmoid', color: '#00ff88', fn: x => 1 / (1 + Math.exp(-x)) },
                { name: 'Tanh', color: '#ffa500', fn: x => Math.tanh(x) }
            ];

            functions.forEach(func => {
                ctx.strokeStyle = func.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let x = -5; x <= 5; x += 0.1) {
                    const y = func.fn(x);
                    const canvasX = centerX + x * scale;
                    const canvasY = centerY - y * scale;
                    if (x === -5) ctx.moveTo(canvasX, canvasY);
                    else ctx.lineTo(canvasX, canvasY);
                }
                ctx.stroke();
            });

            // Legend
            ctx.font = 'bold 12px Arial';
            functions.forEach((func, i) => {
                ctx.fillStyle = func.color;
                ctx.fillRect(10, 10 + i * 20, 10, 10);
                ctx.fillStyle = '#e4e6eb';
                ctx.fillText(func.name, 25, 19 + i * 20);
            });
        }

        // Neural Network Graph
        function drawNetworkGraph(ctx, canvas) {
            const layers = [2, 3, 3, 1];
            const width = canvas.width;
            const height = canvas.height;
            const layerWidth = width / (layers.length + 1);

            ctx.fillStyle = 'rgba(0, 212, 255, 0.05)';
            ctx.fillRect(0, 0, width, height);

            // Draw neurons and connections
            const neuronPositions = [];

            layers.forEach((numNeurons, layerIdx) => {
                const x = (layerIdx + 1) * layerWidth;
                const positions = [];

                for (let i = 0; i < numNeurons; i++) {
                    const y = height / (numNeurons + 1) * (i + 1);
                    positions.push({ x, y });

                    // Draw connections to next layer
                    if (layerIdx < layers.length - 1) {
                        const nextLayerPositions = [];
                        const nextX = (layerIdx + 2) * layerWidth;
                        for (let j = 0; j < layers[layerIdx + 1]; j++) {
                            const nextY = height / (layers[layerIdx + 1] + 1) * (j + 1);
                            nextLayerPositions.push({ x: nextX, y: nextY });
                        }

                        nextLayerPositions.forEach(next => {
                            ctx.strokeStyle = 'rgba(0, 212, 255, 0.2)';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(next.x, next.y);
                            ctx.stroke();
                        });
                    }
                }

                // Draw neurons
                positions.forEach(pos => {
                    ctx.fillStyle = '#00d4ff';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                });

                neuronPositions.push(positions);
            });

            // Labels
            ctx.fillStyle = '#e4e6eb';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Input', layerWidth, height - 10);
            ctx.fillText('Hidden 1', layerWidth * 2, height - 10);
            ctx.fillText('Hidden 2', layerWidth * 3, height - 10);
            ctx.fillText('Output', layerWidth * 4, height - 10);
        }

        // Convolution Animation
        function drawConvolutionAnimation(ctx, canvas) {
            const width = canvas.width;
            const height = canvas.height;

            // Draw input image
            ctx.fillStyle = 'rgba(0, 212, 255, 0.1)';
            ctx.fillRect(20, 20, 150, 150);
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.strokeRect(20, 20, 150, 150);

            // Draw filter
            ctx.fillStyle = 'rgba(255, 107, 53, 0.1)';
            const filterPos = 60 + Math.sin(Date.now() / 1000) * 40;
            ctx.fillRect(filterPos, 60, 60, 60);
            ctx.strokeStyle = '#ff6b35';
            ctx.lineWidth = 3;
            ctx.strokeRect(filterPos, 60, 60, 60);

            // Draw output
            ctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
            ctx.fillRect(width - 170, 20, 150, 150);
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.strokeRect(width - 170, 20, 150, 150);

            // Draw feature map
            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < 5; j++) {
                    const intensity = Math.random() * 100;
                    ctx.fillStyle = `rgba(0, 212, 255, ${intensity / 100})`;
                    ctx.fillRect(width - 160 + i * 25, 30 + j * 25, 20, 20);
                }
            }

            // Labels
            ctx.fillStyle = '#e4e6eb';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Input Image', 20, 190);
            ctx.fillText('Filter', filterPos, 140);
            ctx.fillText('Feature Map', width - 170, 190);
        }

        // Loss Landscape
        function drawLossLandscape(ctx, canvas) {
            const width = canvas.width;
            const height = canvas.height;

            for (let x = 0; x < width; x += 20) {
                for (let y = 0; y < height; y += 20) {
                    const nx = (x - width / 2) / (width / 4);
                    const ny = (y - height / 2) / (height / 4);
                    const loss = nx * nx + ny * ny;
                    const intensity = Math.min(255, loss * 50);
                    ctx.fillStyle = `rgb(${intensity}, ${100}, ${255 - intensity})`;
                    ctx.fillRect(x, y, 20, 20);
                }
            }

            // Draw descent path
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const startX = width / 2 + 80;
            const startY = height / 2 + 80;
            ctx.moveTo(startX, startY);

            for (let i = 0; i < 20; i++) {
                const angle = Math.atan2(startY - height / 2, startX - width / 2);
                const newX = startX - Math.cos(angle) * 15;
                const newY = startY - Math.sin(angle) * 15;
                ctx.lineTo(newX, newY);
            }
            ctx.stroke();

            // Minimum point
            ctx.fillStyle = '#00ff88';
            ctx.beginPath();
            ctx.arc(width / 2, height / 2, 8, 0, Math.PI * 2);
            ctx.fill();
        }

        // YOLO Grid
        function drawYOLOGrid(ctx, canvas) {
            const width = canvas.width;
            const height = canvas.height;
            const gridSize = 7;
            const cellWidth = width / gridSize;
            const cellHeight = height / gridSize;

            // Draw grid
            ctx.strokeStyle = 'rgba(0, 212, 255, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= gridSize; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellWidth, 0);
                ctx.lineTo(i * cellWidth, height);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i * cellHeight);
                ctx.lineTo(width, i * cellHeight);
                ctx.stroke();
            }

            // Draw detected objects
            const detections = [
                { x: 2, y: 2, w: 2, h: 2, conf: 0.95 },
                { x: 4, y: 5, w: 1.5, h: 1.5, conf: 0.87 }
            ];

            detections.forEach(det => {
                ctx.fillStyle = `rgba(255, 107, 53, ${det.conf * 0.5})`;
                ctx.fillRect(det.x * cellWidth, det.y * cellHeight, det.w * cellWidth, det.h * cellHeight);
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 2;
                ctx.strokeRect(det.x * cellWidth, det.y * cellHeight, det.w * cellWidth, det.h * cellHeight);

                ctx.fillStyle = '#ff6b35';
                ctx.font = 'bold 12px Arial';
                ctx.fillText((det.conf * 100).toFixed(0) + '%', det.x * cellWidth + 5, det.y * cellHeight + 15);
            });
        }

        // Attention Matrix
        function drawAttentionMatrix(ctx, canvas) {
            const size = 8;
            const cellSize = Math.min(canvas.width, canvas.height) / size;

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const distance = Math.abs(i - j);
                    const attention = Math.exp(-distance / 2);
                    const intensity = Math.floor(attention * 255);
                    ctx.fillStyle = `rgb(${intensity}, 100, ${200 - intensity})`;
                    ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                }
            }

            // Add labels
            ctx.fillStyle = '#e4e6eb';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            for (let i = 0; i < size; i++) {
                ctx.fillText('w' + i, i * cellSize + cellSize / 2, canvas.height - 5);
            }
        }

        // Math Visualization
        function drawMathVisualization(moduleId) {
            const canvas = document.getElementById(moduleId + '-math-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0f1419';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const mathVizMap = {
                'nn-basics': () => drawNNMath(ctx, canvas),
                'activation': () => drawActivationDerivatives(ctx, canvas),
                'loss': () => drawLossComparison(ctx, canvas),
                'optimizers': () => drawOptimizerSteps(ctx, canvas),
                'backprop': () => drawChainRule(ctx, canvas),
                'conv-layer': () => drawConvolutionMath(ctx, canvas),
                'pooling': () => drawPoolingMath(ctx, canvas),
                'regularization': () => drawRegularizationMath(ctx, canvas),
                'transformers': () => drawAttentionMath(ctx, canvas),
                'rnn': () => drawRNNMath(ctx, canvas)
            };

            if (mathVizMap[moduleId]) {
                mathVizMap[moduleId]();
            } else {
                drawDefaultMathVisualization(ctx, canvas);
            }
        }

        // Application Visualization
        function drawApplicationVisualization(moduleId) {
            const canvas = document.getElementById(moduleId + '-app-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0f1419';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const appVizMap = {
                'nn-basics': () => drawNNApplications(ctx, canvas),
                'cnn-basics': () => drawCNNApplications(ctx, canvas),
                'conv-layer': () => drawConvolutionApplications(ctx, canvas),
                'yolo': () => drawYOLOApplications(ctx, canvas),
                'semantic-seg': () => drawSegmentationApplications(ctx, canvas),
                'instance-seg': () => drawInstanceSegmentationApps(ctx, canvas),
                'face-recog': () => drawFaceRecognitionApps(ctx, canvas),
                'transformers': () => drawTransformerApps(ctx, canvas),
                'bert': () => drawBERTApplications(ctx, canvas),
                'gpt': () => drawGPTApplications(ctx, canvas),
                'gans': () => drawGANApplications(ctx, canvas),
                'diffusion': () => drawDiffusionApplications(ctx, canvas)
            };

            if (appVizMap[moduleId]) {
                appVizMap[moduleId]();
            } else {
                drawDefaultApplicationVisualization(ctx, canvas);
            }
        }

        // Math visualization helper functions
        function drawNNMath(ctx, canvas) {
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Forward Pass: y = œÉ(Wx + b)', canvas.width / 2, 50);
            ctx.font = '14px Arial';
            ctx.fillStyle = '#00ff88';
            ctx.fillText('Linear combination + Non-linearity', canvas.width / 2, 100);
            ctx.fillStyle = '#ffa500';
            ctx.fillText('W: weights, b: bias, œÉ: activation', canvas.width / 2, 150);
        }

        function drawActivationDerivatives(ctx, canvas) {
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const scale = 40;

            ctx.strokeStyle = 'rgba(0, 212, 255, 0.2)';
            ctx.lineWidth = 1;
            for (let i = -5; i <= 5; i += 1) {
                ctx.beginPath();
                ctx.moveTo(centerX + i * scale, centerY - 5 * scale);
                ctx.lineTo(centerX + i * scale, centerY + 5 * scale);
                ctx.stroke();
            }

            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let x = -5; x <= 5; x += 0.1) {
                const y = 1 / (1 + Math.exp(-x)) * (1 - 1 / (1 + Math.exp(-x)));
                const canvasX = centerX + x * scale;
                const canvasY = centerY - y * scale * 10;
                if (x === -5) ctx.moveTo(canvasX, canvasY);
                else ctx.lineTo(canvasX, canvasY);
            }
            ctx.stroke();

            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("Sigmoid Derivative: œÉ'(x) = œÉ(x)(1-œÉ(x))", canvas.width / 2, 30);
        }

        function drawLossComparison(ctx, canvas) {
            const width = canvas.width;
            const height = canvas.height;

            // MSE
            ctx.fillStyle = 'rgba(0, 212, 255, 0.2)';
            ctx.fillRect(20, 60, width / 2 - 30, height - 100);
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('MSE Loss', width / 4, 45);
            ctx.font = '12px Arial';
            ctx.fillText('L = (1/n)Œ£(y-≈∑)¬≤', width / 4, 90);
            ctx.fillText('Regression', width / 4, 115);

            // Cross-Entropy
            ctx.fillStyle = 'rgba(255, 107, 53, 0.2)';
            ctx.fillRect(width / 2 + 10, 60, width / 2 - 30, height - 100);
            ctx.fillStyle = '#ff6b35';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('Cross-Entropy Loss', width * 3 / 4, 45);
            ctx.font = '12px Arial';
            ctx.fillText('L = -Œ£(y¬∑log(≈∑))', width * 3 / 4, 90);
            ctx.fillText('Classification', width * 3 / 4, 115);
        }

        function drawOptimizerSteps(ctx, canvas) {
            const width = canvas.width;
            const height = canvas.height;
            const centerY = height / 2;

            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('SGD', width / 4, 50);
            ctx.font = '12px Arial';
            ctx.fillText('w = w - Œ±¬∑‚àáL', width / 4, 100);

            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Momentum', width / 2, 50);
            ctx.font = '12px Arial';
            ctx.fillText('v = Œ≤¬∑v + (1-Œ≤)¬∑‚àáL', width / 2, 100);

            ctx.fillStyle = '#ffa500';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Adam', width * 3 / 4, 50);
            ctx.font = '12px Arial';
            ctx.fillText('Adaptive learning rate', width * 3 / 4, 100);
        }

        function drawChainRule(ctx, canvas) {
            const width = canvas.width;
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Backpropagation Chain Rule', width / 2, 50);
            ctx.font = '12px Arial';
            ctx.fillStyle = '#00d4ff';
            ctx.fillText('dL/dW = dL/d≈∑ ¬∑ d≈∑/da ¬∑ da/dz ¬∑ dz/dW', width / 2, 100);
            ctx.fillStyle = '#ffa500';
            ctx.fillText('Compute gradient by multiplying partial derivatives', width / 2, 150);
        }

        function drawConvolutionMath(ctx, canvas) {
            ctx.fillStyle = '#ff6b35';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Convolution Operation', canvas.width / 2, 50);
            ctx.font = '12px Arial';
            ctx.fillStyle = '#00d4ff';
            ctx.fillText('y[i,j] = Œ£ Œ£ w[m,n] * x[i+m,j+n] + b', canvas.width / 2, 100);
            ctx.fillStyle = '#00ff88';
            ctx.fillText('Sliding window element-wise multiplication and summation', canvas.width / 2, 150);
        }

        function drawPoolingMath(ctx, canvas) {
            const width = canvas.width;
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Max Pooling', width / 3, 50);
            ctx.font = '12px Arial';
            ctx.fillText('y = max(neighborhood)', width / 3, 100);

            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('Average Pooling', width * 2 / 3, 50);
            ctx.font = '12px Arial';
            ctx.fillText('y = avg(neighborhood)', width * 2 / 3, 100);

            ctx.fillStyle = '#ffa500';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Reduces spatial dimensions', width / 2, 150);
        }

        function drawRegularizationMath(ctx, canvas) {
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('L1 Regularization: L = Loss + ŒªŒ£|w|', canvas.width / 2, 60);
            ctx.fillStyle = '#00ff88';
            ctx.fillText('L2 Regularization: L = Loss + ŒªŒ£w¬≤', canvas.width / 2, 110);
            ctx.fillStyle = '#ffa500';
            ctx.fillText('Prevents overfitting by penalizing large weights', canvas.width / 2, 160);
        }

        function drawAttentionMath(ctx, canvas) {
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Attention Mechanism', canvas.width / 2, 50);
            ctx.font = '12px Arial';
            ctx.fillStyle = '#00ff88';
            ctx.fillText('Attention(Q,K,V) = softmax(QK^T/‚àöd_k) ¬∑ V', canvas.width / 2, 100);
            ctx.fillStyle = '#ffa500';
            ctx.fillText('Query-Key matching determines how much to focus on each value', canvas.width / 2, 150);
        }

        function drawRNNMath(ctx, canvas) {
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('RNN Hidden State Update', canvas.width / 2, 50);
            ctx.font = '12px Arial';
            ctx.fillStyle = '#00ff88';
            ctx.fillText('h_t = œÉ(W_h¬∑h_(t-1) + W_x¬∑x_t + b)', canvas.width / 2, 100);
            ctx.fillStyle = '#ffa500';
            ctx.fillText('Processes sequences step-by-step with recurrent connections', canvas.width / 2, 150);
        }

        // Application visualization helper functions
        function drawNNApplications(ctx, canvas) {
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üì± Stock Price Prediction', canvas.width / 4, 60);
            ctx.fillStyle = '#00ff88';
            ctx.fillText('üè• Medical Diagnosis', canvas.width / 2, 60);
            ctx.fillStyle = '#ffa500';
            ctx.fillText('üéÆ Game AI', canvas.width * 3 / 4, 60);

            ctx.fillStyle = '#ff6b35';
            ctx.font = '12px Arial';
            ctx.fillText('Fraud Detection', canvas.width / 4, 120);
            ctx.fillStyle = '#00d4ff';
            ctx.fillText('Recommendation Systems', canvas.width / 2, 120);
            ctx.fillStyle = '#00ff88';
            ctx.fillText('Credit Scoring', canvas.width * 3 / 4, 120);
        }

        function drawCNNApplications(ctx, canvas) {
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Image Classification', canvas.width / 3, 60);
            ctx.fillStyle = '#00ff88';
            ctx.fillText('Object Detection', canvas.width * 2 / 3, 60);

            ctx.fillStyle = '#ffa500';
            ctx.font = '12px Arial';
            ctx.fillText('Deep Learning Backbone', canvas.width / 2, 150);
        }

        function drawConvolutionApplications(ctx, canvas) {
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üì∑ Image Feature Extraction', canvas.width / 3, 60);
            ctx.fillStyle = '#00ff88';
            ctx.fillText('üîç Edge Detection', canvas.width * 2 / 3, 60);

            ctx.fillStyle = '#ffa500';
            ctx.font = '12px Arial';
            ctx.fillText('Foundation of Computer Vision', canvas.width / 2, 150);
        }

        function drawYOLOApplications(ctx, canvas) {
            ctx.fillStyle = '#ff6b35';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üöó Autonomous Driving', canvas.width / 3, 60);
            ctx.fillStyle = '#00d4ff';
            ctx.fillText('üìπ Real-time Video Detection', canvas.width * 2 / 3, 60);

            ctx.fillStyle = '#00ff88';
            ctx.font = '12px Arial';
            ctx.fillText('Ultra-fast inference for live applications', canvas.width / 2, 150);
        }

        function drawSegmentationApplications(ctx, canvas) {
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üè• Medical Imaging', canvas.width / 3, 60);
            ctx.fillStyle = '#00ff88';
            ctx.fillText('üöó Autonomous Vehicles', canvas.width * 2 / 3, 60);

            ctx.fillStyle = '#ffa500';
            ctx.font = '12px Arial';
            ctx.fillText('Pixel-level understanding of scenes', canvas.width / 2, 150);
        }

        function drawInstanceSegmentationApps(ctx, canvas) {
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üë• Person Detection & Tracking', canvas.width / 3, 60);
            ctx.fillStyle = '#00ff88';
            ctx.fillText('üçé Object Instance Counting', canvas.width * 2 / 3, 60);

            ctx.fillStyle = '#ffa500';
            ctx.font = '12px Arial';
            ctx.fillText('Separates overlapping objects', canvas.width / 2, 150);
        }

        function drawFaceRecognitionApps(ctx, canvas) {
            ctx.fillStyle = '#ffa500';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üì± Phone Unlock', canvas.width / 3, 60);
            ctx.fillStyle = '#00d4ff';
            ctx.fillText('üîí Security Systems', canvas.width * 2 / 3, 60);

            ctx.fillStyle = '#00ff88';
            ctx.font = '12px Arial';
            ctx.fillText('Identity verification and access control', canvas.width / 2, 150);
        }

        function drawTransformerApps(ctx, canvas) {
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üí¨ ChatGPT / LLMs', canvas.width / 3, 60);
            ctx.fillStyle = '#00ff88';
            ctx.fillText('üåê Machine Translation', canvas.width * 2 / 3, 60);

            ctx.fillStyle = '#ffa500';
            ctx.font = '12px Arial';
            ctx.fillText('Foundation of modern NLP and beyond', canvas.width / 2, 150);
        }

        function drawBERTApplications(ctx, canvas) {
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üîç Semantic Search', canvas.width / 3, 60);
            ctx.fillStyle = '#00ff88';
            ctx.fillText('‚ùì Question Answering', canvas.width * 2 / 3, 60);

            ctx.fillStyle = '#ffa500';
            ctx.font = '12px Arial';
            ctx.fillText('Deep language understanding', canvas.width / 2, 150);
        }

        function drawGPTApplications(ctx, canvas) {
            ctx.fillStyle = '#ff6b35';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('‚úçÔ∏è Text Generation', canvas.width / 3, 60);
            ctx.fillStyle = '#00d4ff';
            ctx.fillText('üí° Idea Assistance', canvas.width * 2 / 3, 60);

            ctx.fillStyle = '#00ff88';
            ctx.font = '12px Arial';
            ctx.fillText('Powerful autoregressive language models', canvas.width / 2, 150);
        }

        function drawGANApplications(ctx, canvas) {
            ctx.fillStyle = '#ff6b35';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üé® Image Generation', canvas.width / 3, 60);
            ctx.fillStyle = '#00d4ff';
            ctx.fillText('üé≠ Style Transfer', canvas.width * 2 / 3, 60);

            ctx.fillStyle = '#00ff88';
            ctx.font = '12px Arial';
            ctx.fillText('Creative content generation and enhancement', canvas.width / 2, 150);
        }

        function drawDiffusionApplications(ctx, canvas) {
            ctx.fillStyle = '#ffa500';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üñºÔ∏è Image Synthesis', canvas.width / 3, 60);
            ctx.fillStyle = '#00d4ff';
            ctx.fillText('üé¨ Stable Diffusion', canvas.width * 2 / 3, 60);

            ctx.fillStyle = '#00ff88';
            ctx.font = '12px Arial';
            ctx.fillText('State-of-the-art generative AI', canvas.width / 2, 150);
        }

        // Missing visualization stub functions
        function drawNeuronAnimation(ctx, canvas) {
            drawNetworkGraph(ctx, canvas);
        }

        function drawDecisionBoundary(ctx, canvas) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Draw decision boundary line
            ctx.strokeStyle = '#ff6b35';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();

            // Draw sample points
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                ctx.fillStyle = y < centerY ? '#00d4ff' : '#00ff88';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawWeightDistribution(ctx, canvas) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Draw Gaussian distribution
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = -100; x <= 100; x += 2) {
                const y = Math.exp(-(x * x) / 500) * 80;
                const canvasX = centerX + x;
                const canvasY = centerY - y;
                if (x === -100) ctx.moveTo(canvasX, canvasY);
                else ctx.lineTo(canvasX, canvasY);
            }
            ctx.stroke();

            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Weight Distribution (Xavier/He Init)', centerX, 50);
        }

        function drawConvergencePaths(ctx, canvas) {
            drawLossLandscape(ctx, canvas);
        }

        function drawGradientFlow(ctx, canvas) {
            drawChainRule(ctx, canvas);
        }

        function drawOverfitComparison(ctx, canvas) {
            const width = canvas.width;
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Without Regularization', width / 4, 40);
            ctx.fillStyle = '#ff6b35';
            ctx.fillText('With Regularization', width * 3 / 4, 40);

            // Draw wavy overfit line
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = 0; x < width / 2 - 20; x += 5) {
                const y = 100 + Math.sin(x / 10) * 30 + Math.random() * 20;
                if (x === 0) ctx.moveTo(x + 20, y);
                else ctx.lineTo(x + 20, y);
            }
            ctx.stroke();

            // Draw smooth regularized line
            ctx.strokeStyle = '#ff6b35';
            ctx.beginPath();
            for (let x = 0; x < width / 2 - 20; x += 5) {
                const y = 100 + Math.sin(x / 20) * 15;
                if (x === 0) ctx.moveTo(x + width / 2 + 20, y);
                else ctx.lineTo(x + width / 2 + 20, y);
            }
            ctx.stroke();
        }

        function drawBatchNormalization(ctx, canvas) {
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Batch Normalization: Œº=0, œÉ¬≤=1', canvas.width / 2, 50);

            // Draw before/after distributions
            ctx.fillStyle = '#ffa500';
            ctx.fillText('Input Distribution', canvas.width / 4, 100);
            ctx.fillStyle = '#00ff88';
            ctx.fillText('Normalized Distribution', canvas.width * 3 / 4, 100);
        }

        function drawImageMatrix(ctx, canvas) {
            const cellSize = 20;
            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 10; j++) {
                    const intensity = Math.random();
                    ctx.fillStyle = `rgba(0, 212, 255, ${intensity})`;
                    ctx.fillRect(i * cellSize + 100, j * cellSize + 100, cellSize, cellSize);
                }
            }
            ctx.fillStyle = '#e4e6eb';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Image as Matrix (Pixel Values)', canvas.width / 2, 50);
        }

        function drawPoolingDemo(ctx, canvas) {
            const cellSize = 30;
            const matrix = [[12, 20, 30, 0], [8, 12, 2, 0], [34, 70, 37, 4], [112, 100, 25, 12]];

            ctx.fillStyle = '#e4e6eb';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Max Pooling Demo (2x2)', canvas.width / 2, 30);

            // Draw input matrix
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    ctx.strokeStyle = '#00d4ff';
                    ctx.strokeRect(50 + j * cellSize, 50 + i * cellSize, cellSize, cellSize);
                    ctx.fillStyle = '#e4e6eb';
                    ctx.font = '10px Arial';
                    ctx.fillText(matrix[i][j], 50 + j * cellSize + cellSize / 2, 50 + i * cellSize + cellSize / 2 + 4);
                }
            }

            // Draw output (max pooled)
            const pooled = [[20, 30], [112, 37]];
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < 2; j++) {
                    ctx.strokeStyle = '#00ff88';
                    ctx.strokeRect(250 + j * cellSize * 1.5, 70 + i * cellSize * 1.5, cellSize * 1.5, cellSize * 1.5);
                    ctx.fillStyle = '#00ff88';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(pooled[i][j], 250 + j * cellSize * 1.5 + cellSize * 0.75, 70 + i * cellSize * 1.5 + cellSize * 0.75 + 5);
                }
            }
        }

        function drawCNNArchitecture(ctx, canvas) {
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Input', 60, 200);
            ctx.fillText('Conv', 160, 200);
            ctx.fillText('Pool', 260, 200);
            ctx.fillText('Conv', 360, 200);
            ctx.fillText('Pool', 460, 200);
            ctx.fillText('FC', 560, 200);
            ctx.fillText('Output', 660, 200);

            // Draw blocks
            const blocks = [60, 160, 260, 360, 460, 560, 660];
            blocks.forEach((x, i) => {
                const height = i === 0 ? 100 : (i < blocks.length - 2 ? 80 - i * 10 : 60);
                ctx.strokeStyle = '#00d4ff';
                ctx.strokeRect(x - 30, 100, 60, height);
            });
        }

        function drawLearnedFilters(ctx, canvas) {
            ctx.fillStyle = '#e4e6eb';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('CNN Learned Filters', canvas.width / 2, 30);

            const labels = ['Edges', 'Textures', 'Patterns', 'Objects'];
            labels.forEach((label, i) => {
                const x = (i + 1) * canvas.width / 5;
                ctx.fillStyle = '#ff6b35';
                ctx.font = 'bold 12px Arial';
                ctx.fillText(label, x, 80);

                // Draw filter representation
                for (let j = 0; j < 3; j++) {
                    for (let k = 0; k < 3; k++) {
                        const intensity = Math.random();
                        ctx.fillStyle = `rgba(0, 212, 255, ${intensity})`;
                        ctx.fillRect(x - 20 + k * 12, 100 + j * 12, 10, 10);
                    }
                }
            });
        }

        function drawLeNetArchitecture(ctx, canvas) { drawCNNArchitecture(ctx, canvas); }
        function drawAlexNetArchitecture(ctx, canvas) { drawCNNArchitecture(ctx, canvas); }
        function drawVGGArchitecture(ctx, canvas) { drawCNNArchitecture(ctx, canvas); }
        function drawResNetArchitecture(ctx, canvas) { drawCNNArchitecture(ctx, canvas); }
        function drawInceptionModule(ctx, canvas) { drawCNNArchitecture(ctx, canvas); }
        function drawMobileNetArchitecture(ctx, canvas) { drawCNNArchitecture(ctx, canvas); }
        function drawTransferLearning(ctx, canvas) { drawCNNArchitecture(ctx, canvas); }

        function drawBoundingBoxes(ctx, canvas) {
            // Draw sample image
            ctx.fillStyle = 'rgba(0, 212, 255, 0.1)';
            ctx.fillRect(50, 50, 300, 300);

            // Draw bounding boxes
            ctx.strokeStyle = '#ff6b35';
            ctx.lineWidth = 3;
            ctx.strokeRect(100, 100, 150, 150);
            ctx.fillStyle = '#ff6b35';
            ctx.font = 'bold 12px Arial';
            ctx.fillText('Dog 95%', 105, 95);

            ctx.strokeStyle = '#00ff88';
            ctx.strokeRect(180, 200, 100, 80);
            ctx.fillStyle = '#00ff88';
            ctx.fillText('Cat 87%', 185, 195);
        }

        function drawRCNNPipeline(ctx, canvas) { drawBoundingBoxes(ctx, canvas); }
        function drawSSDDetector(ctx, canvas) { drawBoundingBoxes(ctx, canvas); }

        function drawSemanticSegmentation(ctx, canvas) {
            const cellSize = 15;
            const colors = ['rgba(0, 212, 255, 0.5)', 'rgba(255, 107, 53, 0.5)', 'rgba(0, 255, 136, 0.5)'];

            for (let i = 0; i < 20; i++) {
                for (let j = 0; j < 20; j++) {
                    ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                    ctx.fillRect(i * cellSize + 100, j * cellSize + 50, cellSize, cellSize);
                }
            }

            ctx.fillStyle = '#e4e6eb';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Pixel-wise Classification', canvas.width / 2, 30);
        }

        function drawInstanceSegmentation(ctx, canvas) { drawSemanticSegmentation(ctx, canvas); }

        function drawFaceEmbeddings(ctx, canvas) {
            ctx.fillStyle = '#e4e6eb';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Face Embedding Space', canvas.width / 2, 30);

            // Draw embedding vectors
            const faces = 5;
            for (let i = 0; i < faces; i++) {
                const x = 100 + Math.random() * (canvas.width - 200);
                const y = 100 + Math.random() * 200;
                ctx.fillStyle = '#00d4ff';
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawAutoencoderArchitecture(ctx, canvas) {
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';

            const stages = ['Input', 'Encoder', 'Latent', 'Decoder', 'Output'];
            stages.forEach((label, i) => {
                const x = (i + 1) * canvas.width / 6;
                ctx.fillText(label, x, 50);
                const height = i === 2 ? 40 : (i === 0 || i === 4 ? 100 : 70);
                ctx.strokeStyle = '#00d4ff';
                ctx.strokeRect(x - 30, 100, 60, height);
            });
        }

        function drawGANsGame(ctx, canvas) {
            ctx.fillStyle = '#ff6b35';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Generator', canvas.width / 3, 50);
            ctx.fillStyle = '#00d4ff';
            ctx.fillText('Discriminator', canvas.width * 2 / 3, 50);

            // DrawGenerator
            ctx.strokeStyle = '#ff6b35';
            ctx.strokeRect(canvas.width / 3 - 50, 100, 100, 100);

            // Draw Discriminator
            ctx.strokeStyle = '#00d4ff';
            ctx.strokeRect(canvas.width * 2 / 3 - 50, 100, 100, 100);

            // Draw arrow
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(canvas.width / 3 + 50, 150);
            ctx.lineTo(canvas.width * 2 / 3 - 50, 150);
            ctx.stroke();
        }

        function drawDiffusionProcess(ctx, canvas) {
            const steps = 5;
            const stepWidth = canvas.width / (steps + 1);

            ctx.fillStyle = '#e4e6eb';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Diffusion Process: From Noise to Image', canvas.width / 2, 30);

            for (let i = 0; i < steps; i++) {
                const x = (i + 1) * stepWidth;
                const noise = 1 - (i / steps);
                ctx.fillStyle = `rgba(0, 212, 255, ${1 - noise})`;
                ctx.fillRect(x - 40, 100, 80, 80);
                ctx.strokeStyle = '#00d4ff';
                ctx.strokeRect(x - 40, 100, 80, 80);
            }
        }

        function drawRNNUnrolled(ctx, canvas) {
            const cells = 5;
            const cellWidth = canvas.width / (cells + 1);

            ctx.fillStyle = '#e4e6eb';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Unrolled RNN', canvas.width / 2, 30);

            for (let i = 0; i < cells; i++) {
                const x = (i + 1) * cellWidth;
                ctx.strokeStyle = '#00d4ff';
                ctx.strokeRect(x - 30, 100, 60, 60);

                if (i < cells - 1) {
                    ctx.strokeStyle = '#ff6b35';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + 30, 130);
                    ctx.lineTo(x + cellWidth - 30, 130);
                    ctx.stroke();
                }
            }
        }

        function drawBERTProcess(ctx, canvas) { drawAttentionMatrix(ctx, canvas); }
        function drawGPTGeneration(ctx, canvas) { drawAttentionMatrix(ctx, canvas); }
        function drawVisionTransformer(ctx, canvas) { drawAttentionMatrix(ctx, canvas); }

        function drawVisualization(moduleId) {
            drawConceptsVisualization(moduleId);
        }

        // Animation and download utilities
        function toggleVizAnimation(moduleId) {
            window.vizAnimating = !window.vizAnimating;
            if (window.vizAnimating) {
                animateVisualization(moduleId);
            }
        }

        function animateVisualization(moduleId) {
            if (!window.vizAnimating) return;
            drawConceptsVisualization(moduleId);
            setTimeout(() => animateVisualization(moduleId), 150);
        }

        function downloadViz(moduleId) {
            const canvas = document.getElementById(moduleId + '-canvas');
            if (!canvas) return;

            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = moduleId + '-visualization.png';
            link.click();
        }

        initDashboard();
    </script>
</body>

</html>